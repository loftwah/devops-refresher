# Dynamic Programming Pattern Hub

Dynamic programming builds solutions from subproblems. Think of it as memoised postmortems: solve a small case, cache the result, and reuse it for bigger scenarios.

## Core Techniques

- **1D DP**: Linear progression with rolling arrays (climbing stairs, max subarray).
- **2D Grid DP**: Path counting or cost minimisation across matrices.
- **State Machine / Bitmasking**: Multiple dimensions of state (e.g., stock trading with cooldowns).
- **Knapsack / Subset**: Combinatorial selection problems.

## Target Problems

- Fibonacci, Climbing Stairs (entry point for memoisation vs tabulation)
- House Robber / House Robber II (circular constraints)
- Longest Increasing Subsequence
- Coin Change / Minimum Path Sum
- Edit Distance / Word Break

## DevOps Parallels

- Cost optimisation across environments with shared constraints.
- Rolling out blue/green deployments with state tracking per stage.
- Planning maintenance windows while minimising downtime across services.

> When writing DP walkthroughs, emphasise base cases, recurrence, and space trimsâ€”great fodder for NotebookLM audio explanations.
